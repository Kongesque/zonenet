{% extends 'base.html' %}
{% block head %}
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
{% endblock %}


{% block content %}
<main id="content" class="relative flex-1 flex flex-col items-center overflow-y-auto w-full">
    <div class="w-full flex flex-col lg:flex-row gap-6 p-4">
        <!-- Video Section (Left) -->
        <div class="flex-1 flex flex-col min-w-0">
            <div class="w-full rounded-xl overflow-hidden shadow-lg bg-black relative pt-[56.25%]">
                <video class="absolute top-0 left-0 w-full h-full object-contain" controls>
                    <source src="{{ url_for('media_file', filename='outputs/' + 'output_' + taskID + '.mp4') }}"
                        type="video/mp4">
                </video>
            </div>
        </div>

        <!-- Analytics/Toolbar Section (Right) -->
        <div class="w-full lg:w-96 flex-shrink-0 flex flex-col gap-4 overflow-y-auto">
            <!-- Chart Section -->
            <div class="w-full bg-secondary-bg rounded-xl p-4 shadow-sm border border-primary-border">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-text-color font-semibold text-lg">Analytics</h3>
                </div>
                <div class="w-full h-48">
                    <canvas id="analyticsChart"></canvas>
                </div>
            </div>

            <!-- Statistics Summary -->
            <div class="w-full bg-secondary-bg rounded-xl p-4 shadow-sm border border-primary-border">
                <h3 class="text-text-color font-semibold text-lg mb-3">Statistics</h3>
                <div id="statsContainer" class="space-y-3">
                    <!-- Will be populated by JavaScript -->
                </div>
            </div>

            <!-- Activity Heatmap -->
            <div class="w-full bg-secondary-bg rounded-xl p-4 shadow-sm border border-primary-border">
                <h3 class="text-text-color font-semibold text-lg mb-3">Activity Over Time</h3>
                <div class="h-32">
                    <canvas id="heatmapChart"></canvas>
                </div>
            </div>

            <!-- Export Options -->
            <div class="w-full bg-secondary-bg rounded-xl p-4 shadow-sm border border-primary-border">
                <h3 class="text-text-color font-semibold text-lg mb-3">Export Data</h3>
                <div class="flex gap-2">
                    <a href="{{ url_for('export_csv', task_id=taskID) }}"
                        class="btn-primary flex-1 flex items-center justify-center gap-2 hover:bg-hover-btn py-2 text-center text-sm">
                        <div class="w-3.5 h-3.5 bg-current mask-icon"
                            style="--mask-url: url('{{ url_for('static', filename='img/icons/download.svg') }}');">
                        </div>
                        CSV
                    </a>
                    <a href="{{ url_for('export_json', task_id=taskID) }}"
                        class="btn-primary flex-1 flex items-center justify-center gap-2 hover:bg-hover-btn py-2 text-center text-sm">
                        <div class="w-3.5 h-3.5 bg-current mask-icon"
                            style="--mask-url: url('{{ url_for('static', filename='img/icons/file-json.svg') }}');">
                        </div>
                        JSON
                    </a>
                </div>
            </div>

            <!-- Video Details -->
            <div
                class="w-full bg-secondary-bg rounded-xl p-4 shadow-sm border border-primary-border flex flex-col gap-2 text-sm text-secondary-text">
                <h3 class="text-text-color font-semibold text-lg mb-2">Details</h3>
                <p class="flex justify-between">
                    <span>Resolution:</span>
                    <span class="value text-text-color">{{ width }} × {{ height }} px</span>
                </p>
                <p class="flex justify-between">
                    <span>Process Time:</span>
                    <span class="value text-text-color">{{ process_time }} s</span>
                </p>
            </div>
        </div>
    </div>
</main>
{% endblock %}

{% block scripts %}
<script id="detection-data" type="application/json">
    {{ detection_data | tojson }}
</script>
<script id="zones-data" type="application/json">
    {{ zones | tojson }}
</script>
<script id="dwell-data" type="application/json">
    {{ dwell_data | tojson }}
</script>
<script>
    const detectionData = JSON.parse(document.getElementById('detection-data').textContent);
    const zonesData = JSON.parse(document.getElementById('zones-data').textContent) || [];
    const dwellData = JSON.parse(document.getElementById('dwell-data').textContent) || [];
    const processTime = {{ process_time or 0 }};

    // HSL to RGB helper (matches zone.js)
    function hslToRgb(h, s, l) {
        s /= 100;
        l /= 100;
        const k = n => (n + h / 30) % 12;
        const a = s * Math.min(l, 1 - l);
        const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
        return [Math.round(255 * f(0)), Math.round(255 * f(8)), Math.round(255 * f(4))];
    }

    function getColorFromClassId(classId) {
        const hue = (classId * 137.508) % 360;
        return hslToRgb(hue, 85, 55);
    }

    function getZoneColor(zoneId, idx) {
        const zone = zonesData.find(z => z.id === zoneId);
        if (zone && zone.color) {
            return `rgb(${zone.color[0]}, ${zone.color[1]}, ${zone.color[2]})`;
        } else if (zone && zone.classId) {
            const [r, g, b] = getColorFromClassId(zone.classId);
            return `rgb(${r}, ${g}, ${b})`;
        }
        const fallbackColors = ['#1F6F65', '#F59E0B', '#EF4444', '#8B5CF6', '#10B981'];
        return fallbackColors[idx % fallbackColors.length];
    }

    // Calculate statistics for each zone
    function calculateStats(zoneEvents, labels, zoneId) {
        let maxCount = 0;
        let maxTime = 0;
        let total = 0;
        let lastCount = 0;

        labels.forEach(time => {
            const count = zoneEvents[zoneId]?.[time];
            if (count !== undefined) {
                lastCount = count;
            }
            if (lastCount > maxCount) {
                maxCount = lastCount;
                maxTime = time;
            }
        });

        total = lastCount;
        const avgPerMinute = processTime > 0 ? (total / (processTime / 60)).toFixed(1) : 0;

        return { total, peak: maxCount, peakTime: maxTime, avgPerMinute };
    }

    // Render statistics UI with dwell time
    function renderStats(statsMap, zoneColors) {
        const container = document.getElementById('statsContainer');
        if (!container) return;

        // Calculate dwell time stats per zone
        const dwellStats = {};
        if (dwellData && dwellData.length > 0) {
            dwellData.forEach(d => {
                const zoneId = d.zone_id;
                if (!dwellStats[zoneId]) {
                    dwellStats[zoneId] = { total: 0, count: 0 };
                }
                dwellStats[zoneId].total += d.duration;
                dwellStats[zoneId].count++;
            });
        }

        let html = '';
        Object.entries(statsMap).forEach(([zoneId, stats], idx) => {
            const zone = zonesData.find(z => z.id === zoneId);
            const zoneName = zone?.label || `Zone ${idx + 1}`;
            const color = zoneColors[zoneId];

            // Calculate average dwell time
            const dwell = dwellStats[zoneId];
            const avgDwell = dwell && dwell.count > 0 ? (dwell.total / dwell.count).toFixed(1) : '—';

            html += `
                <div class="p-3 bg-primary-color rounded-lg border border-primary-border">
                    <div class="flex items-center gap-2 mb-2">
                        <div class="w-3 h-3 rounded-full" style="background-color: ${color}"></div>
                        <span class="text-sm font-medium text-text-color">${zoneName}</span>
                    </div>
                    <div class="grid grid-cols-4 gap-2 text-center text-xs">
                        <div>
                            <div class="text-lg font-bold text-dropzone-accent">${stats.total}</div>
                            <div class="text-muted-foreground">Total</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-text-color">${stats.peak}</div>
                            <div class="text-muted-foreground">Peak</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-text-color">${stats.avgPerMinute}</div>
                            <div class="text-muted-foreground">/min</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-text-color">${avgDwell}</div>
                            <div class="text-muted-foreground">Dwell(s)</div>
                        </div>
                    </div>
                </div>
            `;
        });

        container.innerHTML = html || '<p class="text-sm text-muted-foreground italic">No data available</p>';
    }

    if (detectionData && detectionData.length > 0) {
        const ctx = document.getElementById('analyticsChart').getContext('2d');

        // Group detection events by zone
        const zoneEvents = {};
        const allTimes = new Set();

        detectionData.forEach(d => {
            const zoneId = d.zone_id || 'default';
            if (!zoneEvents[zoneId]) {
                zoneEvents[zoneId] = {};
            }
            zoneEvents[zoneId][d.time] = d.count;
            allTimes.add(d.time);
        });

        const labels = Array.from(allTimes).sort((a, b) => a - b);
        const zoneIds = Object.keys(zoneEvents);

        // Build datasets and collect stats
        const datasets = [];
        const statsMap = {};
        const zoneColors = {};
        const peakAnnotations = {};

        zoneIds.forEach((zoneId, idx) => {
            const color = getZoneColor(zoneId, idx);
            zoneColors[zoneId] = color;

            // Calculate stats
            const stats = calculateStats(zoneEvents, labels, zoneId);
            statsMap[zoneId] = stats;

            // Build data array
            let lastCount = 0;
            const data = labels.map(time => {
                if (zoneEvents[zoneId][time] !== undefined) {
                    lastCount = zoneEvents[zoneId][time];
                }
                return lastCount;
            });

            datasets.push({
                label: zonesData.find(z => z.id === zoneId)?.label || `Zone ${idx + 1}`,
                data: data,
                borderColor: color,
                backgroundColor: color.replace('rgb', 'rgba').replace(')', ', 0.1)'),
                borderWidth: 2,
                pointRadius: 0,
                pointHoverRadius: 4,
                fill: true,
                tension: 0.4
            });

            // Peak annotation
            const peakIndex = labels.indexOf(stats.peakTime);
            if (peakIndex >= 0) {
                peakAnnotations[`peak_${zoneId}`] = {
                    type: 'point',
                    xValue: stats.peakTime,
                    yValue: stats.peak,
                    backgroundColor: color,
                    borderColor: '#fff',
                    borderWidth: 2,
                    radius: 6
                };
            }
        });

        // Render stats
        renderStats(statsMap, zoneColors);

        // Create chart with annotations
        new Chart(ctx, {
            type: 'line',
            data: { labels: labels, datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { intersect: false, mode: 'index' },
                plugins: {
                    legend: {
                        display: datasets.length > 1,
                        position: 'top',
                        labels: { color: '#9ca3af', usePointStyle: true, pointStyle: 'circle' }
                    },
                    tooltip: {
                        backgroundColor: '#1f2937',
                        titleColor: '#f3f4f6',
                        bodyColor: '#d1d5db',
                        padding: 10
                    },
                    annotation: {
                        annotations: peakAnnotations
                    }
                },
                scales: {
                    x: {
                        grid: { display: false },
                        ticks: { color: '#9ca3af', maxTicksLimit: 8 },
                        title: { display: true, text: 'Time (s)', color: '#6b7280' }
                    },
                    y: {
                        grid: { color: 'rgba(55, 65, 81, 0.5)' },
                        ticks: { color: '#9ca3af', precision: 0 },
                        beginAtZero: true
                    }
                }
            }
        });

        // Create Activity Heatmap (bar chart with time buckets)
        if (processTime > 0) {
            const heatmapCtx = document.getElementById('heatmapChart')?.getContext('2d');
            if (heatmapCtx) {
                // Create time buckets (10 buckets across the video duration)
                const numBuckets = Math.min(20, Math.max(5, Math.floor(processTime / 5)));
                const bucketSize = processTime / numBuckets;
                const buckets = Array(numBuckets).fill(0);

                // Count events per bucket
                detectionData.forEach(d => {
                    const bucketIdx = Math.min(numBuckets - 1, Math.floor(d.time / bucketSize));
                    buckets[bucketIdx]++;
                });

                // Find max for color scaling
                const maxEvents = Math.max(...buckets, 1);

                // Generate gradient colors based on activity
                const colors = buckets.map(count => {
                    const intensity = count / maxEvents;
                    // Green (low) to Yellow to Red (high)
                    if (intensity < 0.5) {
                        const g = 200;
                        const r = Math.floor(intensity * 2 * 255);
                        return `rgba(${r}, ${g}, 100, 0.8)`;
                    } else {
                        const r = 255;
                        const g = Math.floor((1 - (intensity - 0.5) * 2) * 200);
                        return `rgba(${r}, ${g}, 100, 0.8)`;
                    }
                });

                const bucketLabels = buckets.map((_, i) =>
                    `${Math.floor(i * bucketSize)}-${Math.floor((i + 1) * bucketSize)}s`
                );

                new Chart(heatmapCtx, {
                    type: 'bar',
                    data: {
                        labels: bucketLabels,
                        datasets: [{
                            label: 'Events',
                            data: buckets,
                            backgroundColor: colors,
                            borderWidth: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: {
                                grid: { display: false },
                                ticks: { color: '#9ca3af', maxRotation: 0, maxTicksLimit: 6 }
                            },
                            y: {
                                grid: { color: 'rgba(55, 65, 81, 0.3)' },
                                ticks: { color: '#9ca3af', precision: 0 },
                                beginAtZero: true
                            }
                        }
                    }
                });
            }
        }
    } else {
        // No data
        document.getElementById('statsContainer').innerHTML =
            '<p class="text-sm text-muted-foreground italic">No detection data available</p>';
    }
</script>
<script src="{{url_for('static', filename='js/result.js')}}"></script>
{% endblock %}